import BasePlatform from "./BasePlatform.js";
import packageVersions from "../main/package-versions.js";
import {startCommand, runCommand, findNodeBin} from "../utils/node-util.js";
import fs, {promises as fsp} from "fs";
import path from "node:path";
import {DeclaredError} from "../utils/js-util.js";
import {fileURLToPath} from 'url';

const __dirname=path.dirname(fileURLToPath(import.meta.url));

let CLOUDFLARE_STUB=`
//
// This file is automatically generated.
//
// Don't edit this file, and don't put it under version control!
//

import MikrokatServer from "./__MikrokatServer.js";
import {guessCloudflareServiceType} from "./__cloudflare-util.js";

$VARS

let serverMap=new Map();

export default {
	async fetch(request, env, ctx) {
		if (env.ASSETS && env.ASSETS.fetch) {
	    	const res = await env.ASSETS.fetch(request);
	    	if (res && res.status!=404) {
	    		return res;
	    	}
		}

		if (!serverMap.get(env)) {
			let serviceMeta={};
			for (let k in env)
				serviceMeta[k]={type: guessCloudflareServiceType(env[k])};

			let envConf={...MIKROKAT_SERVER_CONF};
			envConf.env={...envConf.env,...env};
			envConf.serviceMeta=serviceMeta;

			serverMap.set(env,new MikrokatServer(envConf));
		}

		let server=serverMap.get(env);
		return await server.handleRequest({request,ctx});
	}
}
`;

export default class CloudflarePlatform extends BasePlatform {
	constructor(arg) {
		super(arg);
	}

	async build() {
		await this.project.writeStub(".target/entrypoint.cloudflare.js",CLOUDFLARE_STUB);
		await fsp.copyFile(
			path.join(__dirname,"../main/MikrokatServer.js"),
			path.join(this.project.cwd,".target/__MikrokatServer.js")
		);

		await fsp.copyFile(
			path.join(__dirname,"../utils/cloudflare-util.js"),
			path.join(this.project.cwd,".target/__cloudflare-util.js")
		);
	}

	async init() {
		let pkg=await this.project.processProjectFile("package.json","json",async pkg=>{
			if (!pkg.dependencies) pkg.dependencies={};
			pkg.dependencies.wrangler="^"+packageVersions.wrangler;
		});

		await this.project.processProjectFile("wrangler.json","json",async wrangler=>{
			if (!wrangler) wrangler={};
			wrangler.main=".target/entrypoint.cloudflare.js";

			if (!wrangler.name)
				wrangler.name=pkg.name;

			if (!wrangler.compatibility_date)
				wrangler.compatibility_date=new Date().toISOString().slice(0, 10);

			if (!wrangler.assets)
				wrangler.assets={};

			if (!wrangler.assets.directory)
				wrangler.assets.directory="./public";

			return wrangler;
		});

		await this.project.processProjectFile(".gitignore","lines",async ignore=>{
			if (!ignore.includes(".target")) ignore.push(".target");
			if (!ignore.includes(".wrangler")) ignore.push(".wrangler");
		});
	}

	async verifyInit() {
		if (!fs.existsSync(path.join(this.project.cwd,"wrangler.json")))
			throw new DeclaredError("Cloudflare not initialized, no wrangler.json. Run init.");
	}

	async devServer() {
		let options={
			//waitForOutput: "Ready on",
			nodeCwd: this.project.cwd,
			expect: 0,
			waitForPort: this.project.port
		}

		return await startCommand("wrangler",[
			"dev",
			"--no-live-reload",
			"--cwd",this.project.cwd,
			"--port",this.project.port
		],options);
	}

	async deploy() {
		let options={
			nodeCwd: this.project.cwd,
			expect: 0,
		}

		return await runCommand("wrangler",[
			"deploy",
			"--cwd",this.project.cwd,
		],options);
	}

	async clean({purge}) {
		await fsp.rm(path.join(this.project.cwd,".wrangler"),{recursive: true, force: true});

		if (purge) {
			await fsp.rm(path.join(this.project.cwd,"wrangler.json"),{recursive: true, force: true});

			let pkg=await this.project.processProjectFile("package.json","json",async pkg=>{
				if (!pkg.dependencies) pkg.dependencies={};
				delete pkg.dependencies.wrangler;
			});
		}
	}
}