import BasePlatform from "./BasePlatform.js";
import packageVersions from "../main/package-versions.js";
import {startCommand, findNodeBin} from "../utils/node-util.js";

let CLOUDFLARE_STUB=`
//
// This file is automatically generated.
//
// Don't edit this file, and don't put it under version control!
//

import {MikrokatServer} from "mikrokat/server";
import {guessCloudflareServiceType} from "mikrokat/cloudflare-util";

$VARS

let serverMap=new Map();

export default {
	async fetch(request, env, ctx) {
		if (env.ASSETS && env.ASSETS.fetch) {
	    	const res = await env.ASSETS.fetch(request);
	    	if (res && res.status!=404) {
	    		return res;
	    	}
		}

		if (!serverMap.get(env)) {
			let serviceMeta={};
			for (let k in env)
				serviceMeta[k]={type: guessCloudflareServiceType(env[k])};

			let envConf={...MIKROKAT_SERVER_CONF};
			envConf.env={...envConf.env,...env};
			envConf.serviceMeta=serviceMeta;

			serverMap.set(env,new MikrokatServer(envConf));
		}

		let server=serverMap.get(env);
		return await server.handleRequest({request,ctx});
	}
}
`;

export default class CloudflarePlatform extends BasePlatform {
	constructor(arg) {
		super(arg);
	}

	async build() {
		await this.project.writeStub(".target/entrypoint.cloudflare.js",CLOUDFLARE_STUB);
	}

	async init() {
		let pkg=await this.project.processProjectFile("package.json","json",async pkg=>{
			/*if (!pkg.scripts) pkg.scripts={};
			if (!pkg.scripts["dev:cloudflare"])
				pkg.scripts["dev:cloudflare"]="wrangler dev";

			if (!pkg.scripts["deploy:cloudflare"])
				pkg.scripts["deploy:cloudflare"]="wrangler deploy";*/

			if (!pkg.dependencies) pkg.dependencies={};
			pkg.dependencies.wrangler="^"+packageVersions.wrangler;
		});

		await this.project.processProjectFile("wrangler.json","json",async wrangler=>{
			if (!wrangler) wrangler={};
			wrangler.main=".target/entrypoint.cloudflare.js";

			if (!wrangler.name)
				wrangler.name=pkg.name;

			/*if (!wrangler.build) wrangler.build={};
			wrangler.build.command="PLATFORM=cloudflare npm run build";*/

			if (!wrangler.compatibility_date)
				wrangler.compatibility_date=new Date().toISOString().slice(0, 10);

			if (!wrangler.assets)
				wrangler.assets={};

			if (!wrangler.assets.directory)
				wrangler.assets.directory="./public";

			return wrangler;
		});

		await this.project.processProjectFile(".gitignore","lines",async ignore=>{
			if (!ignore.includes(".target")) ignore.push(".target");
			if (!ignore.includes(".wrangler")) ignore.push(".wrangler");
		});

		/*this.project.log("Cloudflare initialized. Start a dev server with:");
		this.project.log();
		this.project.log("  npm run dev:cloudflare");
		this.project.log();
		this.project.log("Deploy with:");
		this.project.log();
		this.project.log("  npm run deploy:cloudflare");
		this.project.log();*/
	}

	async devServer() {
		let options={
			waitForOutput: "Ready on",
			nodeCwd: this.project.cwd,
			expect: 0
		}

		return await startCommand("wrangler",[
			"dev",
			"--no-live-reload",
			"--cwd",this.project.cwd,
			"--port",this.project.port
		],options);
	}

	async deploy() {

	}
}